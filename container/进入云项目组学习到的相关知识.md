# 云项目组“上天”过程中发现的那些“神仙”

来云组已经两个月有余了，在我们组上天的过程中，碰到了很多之前开发中完全用不到的技术知识点，也就是我所说的“神仙”，今天我就来给大家盘一盘这些个“神仙”到底都是些什么玩意。

## 继续从PaaS说起

### 容器的兴起

强哥在之前的某次sprint技术分享会中给大家讲过了PaaS和SaaS等概念，那我这次就继续从PaaS开始，先来讲讲他的前世今生吧。

早在2013年前后，服务端的技术是云端计算的天下，当时有大量的云计算厂商涌入市场，比较著名的有`AWS`和`OpenStack`，他们将虚无缥缈的云端计算这种高大上的概念，固化成了实实在在的虚拟机技术，当时的主流用户，也都是将自己的应用上传到云端的虚拟机中，以之前管理物理机的方式管理着可能是一群云端的虚拟服务器。

而就在这个时候，一家主打开源PaaS项目的平台`Cloud Foundry`诞生了。与传统的提供云上虚拟机服务不同，Cloud Foundry的PaaS所提供的服务是`应用托管`的功能，也就是用户只需要通过一条简单的命令比如：`cf push "我的应用"`，就可以把自己的项目部署在可能成千上万台的终端服务器上。然后平台对这些项目提供分发，灾备，监控，重启等等服务（这其实也是我们组想要给用户提供的最终服务），这些托管服务解放了开发者的生产力，让他们不用再关心应用的运维状况，而是专心开发自己的应用。这就是PaaS的概念，平台即服务。

因此，像Cloud Foundry这样的PaaS项目，最核心的组件就是对一套应用的打包和分发机制，Cloud Foundry为每一种主流的语言都定义了一套打包的方式。而cf push命令，就是将应用打好的包上传到云端的存储中，然后Cloud Foundry调度出一个可运行的虚拟机，通知该虚拟机上的Agent下载并且运行这个打包结果。由此可见，Cloud Foundry的虚拟机中会运行多个用户的多个服务，为了解决服务之间相互隔离的边界问题，Cloud Foundry使用了Linux的Namespace技术对运行的应用进行了隔离和分组，使用Cgroup技术对隔离的应用分配资源，而这也正是容器技术的一部分。

由此我们可以知道，容器技术并不是Docker创建的，而且在Docker兴起之前，就已经被其他公司商用了，但是为什么现在一谈起容器，所有人第一时间想到的就是Docker呢？

上面，我提到了Cloud Foundry的部署需要用户对其应用进行打包，然而就是这个打包的功能，成了Cloud Foundry的一个软肋一直被用户诟病：为了上传PaaS，用户就不得不为每一种语言，每一种框架，甚至是每个版本应用维护一个打好的包，这种打包的方法是毫无章法的，还有可能出现本机运行成功，打了个包上传上去之后就无法运行的情况。然而就在这个时候，这一节的主人`Docker`开始崭露头角了。

Docker是一个当时还叫dotCloud的公司开发的容器项目，在开源的短短几个月后就迅速崛起，并一局将Cloud Foundry赶出了局，然而最可笑的是，在Docker刚开源的时候，Cloud Foundry的首席产品经理 James Bayer就在社区做了一次详细的对比，告诉用户Docker和Cloud Foundry一样是一个使用了Namespace和Cgroup技术的沙箱而已，没什么值得关注的。事实上，Docker也确实就和他所说的一样，但是只做了一点小小的创新，而就是这一点小小的创新，对Cloud Foundry造成了毁灭性的降维打击。这个创新就是`Docker镜像`。

Docker镜像几乎完美地解决了Cloud Foundry对于打包方面的软肋。所谓的镜像，其实也是一个压缩包，但是比起Cloud Foundry那种执行文件+启动脚本的打包结果，镜像提供给用户的是一套完整的运行环境，每一个镜像都可以指定操作系统版本，内部可以构建程序执行的文件结构，并且一份镜像可以完全共享多处使用。Docker给用户提供了一套完善的镜像制作流程，用户也就不用关心自己的语言和框架了，只需要定制对应程序所需要的运行的操作系统环境即可（这一点其实也可以简单的看成是对压缩包这种应用做了底层的抽象，比较契合软件设计的原则。也可以看到，软件行业的一点创新，带来的就是降维级别的打击）。总结一下就是：`Docker 镜像完美解决了两个问题：1是本地环境和服务器环境的差异问题；2是一份镜像所有的机器都可以运行的复用问题`。

在这之后，PaaS的市场，已经完全是Docker的天下了。而之后的故事，我会在下一节再继续讲。

### 一个进程的诞生

好了，讲了半天的故事了，也要说一点干货了：容器到底是个什么玩意，能有这么大的市场和这么多服务端程序员对其青睐？先卖个关子，我先从一个进程说起。

我们都知道，计算机里运行的程序其实都是一个一个的进程，而一个进程其实就是程序执行之后，从磁盘的二进制文件，到内存、寄存器、堆栈指令等等所用到的相关设备状态的一个集合，是`数据和状态综合的动态表现`。而容器技术，其实就是对一个进程的状态和数据进行的一系列`隔离`和`限制`后的结果。因此可以知道，容器的本质其实就是Linux中的一个进程。那具体是怎么做到的呢？

先来说说隔离，我们可以在任意一个装有Docker程序的Linux中执行下列的命令创建一个简单的镜像：

``` shell
$ docker run -it busybox /bin/sh
```

这条语句的大概意思是：用docker运行一个容器，容器的镜像名称叫`busybox`，并且运行之后需要执行的命令是`/bin/sh`，而`-it`参数表示需要使用标准输入`stdin`和分配一个文本输入输出环境`tty`与外部交互。通过这个命令，我们就可以进入到一个容器内部了，分别在容器中和宿主机中执行`top`命令，可以看到以下结果：

![host_container_comparer]()

> 这里要做一个特别的说明，只有Linux中运行的容器是通过对进程进行限制模拟出来的结果，Windows和Mac下的容器，都是通过Docker Desktop操作虚拟机模拟出来的真实的虚拟容器。